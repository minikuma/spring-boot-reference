### **7.Spring Boot Features**   
---
이번 섹션부터는 스프링 부트에 대해 조금 더 자세하게 알아 볼 예정이다. 스프링 부트를 사용할 때 사용자가 정의할 수 있는 주요 기능에 대해 설명할 예정이다.     

---
### **7.1.SpringApplication**    
---
```main()``` 메소드에 ```SpringApplication``` 클래스는 애플리케이션을 편리하게 시작할 수 있게 도움을 준다.  많은 일이 발생할 예정이지만 그냥 ```SpringApplication.run``` 메소드만 실행하면 된다.     

```java
@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

}
```     

애플리케이션이 시작되면 아래와 같은 출력을 볼 수 있다.     

```java
.   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v2.5.2

2021-02-03 10:33:25.224  INFO 17321 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : Starting SpringAppplicationExample using Java 1.8.0_232 on mycomputer with PID 17321 (/apps/myjar.jar started by pwebb)
2021-02-03 10:33:25.226  INFO 17900 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : No active profile set, falling back to default profiles: default
2021-02-03 10:33:26.046  INFO 17321 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-02-03 10:33:26.054  INFO 17900 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-02-03 10:33:26.055  INFO 17900 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-02-03 10:33:26.097  INFO 17900 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-02-03 10:33:26.097  INFO 17900 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 821 ms
2021-02-03 10:33:26.144  INFO 17900 --- [           main] s.tomcat.SampleTomcatApplication         : ServletContext initialized
2021-02-03 10:33:26.376  INFO 17900 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-02-03 10:33:26.384  INFO 17900 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : Started SampleTomcatApplication in 1.514 seconds (JVM running for 1.823)
```      

기본적으로 ```INFO``` 레벨의 로그 정보를 보여주며, 애플리케이션이 시작할 때 필요한 내용들을 보여준다. 만약 ```INFO``` 로그 레벨 이외의 다른 로그 레벨이 필요하다면 다른 로그 레벨을 설정할 수 있다. 애플리케이션의 버전은 기본 패키지에서 구현된 버전을 사용하여 결정된다. 시작할 때 로그 정보를 사용하고 싶지 않으면 ```spring.main.log-startup-info``` 프로퍼티 설정을 ```false``` 로 설정하거나 애플리케이션의 active profiles 에서 끌 수 있다.    

---
### **7.1.2.Startup Failure**   
---
만약 애플리케이션 구동일 실패하였다면, ```FailureAnalyzers``` 에 등록된다.  ```FailureAnalyzers``` 에 등록되면 사용자에게 이미 정의된 에러 메시지와 해당 에러 메시지를 수정하는 방법에 대해 알려준다. 예를 들어 웹 애플리케이션을 구동했는데 해당 포트가 이미 사용중 이라면 사용자는 아래와 같은 메시지를 볼 수 있을 것이다.         

```shell
***************************
APPLICATION FAILED TO START
***************************

Description:

Embedded servlet container failed to start. Port 8080 was already in use.

Action:

Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.
```      

만약 실패 분석기(Fail Analyzers)가 에러를 알려 주지 않는다면, 로그 레벨을 ```DEBUG``` 모드로 변경하거나 ```java -jar``` 명령어를 통해 ```DEBUG``` 로그 레벨로 실행할 수 있다.     

```java -jar myproject-0.0.1-SNAPSHOT.jar --debug```      

---
### **7.1.3.Lazy Initialization**      
---   
```SpringApplication``` 는 애플리케이션의 초기화 시점을 늦출 수 있다. 보통은 애플리케이션을 시작할 때 모두 초기화 작업을 거친다. 지연 초기화를 활성하게 되면, 애플리케이션이 시작할 때 초기화를 하는 것이 아니라 빈이 필요할 때 초기화를 하게 된다. 이로 인해 애플리케이션이 빠르게 구동될 수 있다. 웹 애플리케이션 같은 경우는 HTTP 요청이 유입이 될 대 웹과 관련된 빈들이 초기화된다. 지연 초기화의 단점으로는 애플리케이션에 문제가 발생했을 때 문제 원인 파악이 힘들다는 점을 들 수 있다. 잘못 설정된 빈이 애플리케이션 구동중에는 문제가 없는 것처럼 보이다가 실제 해당 빈을 사용할 시점에 문제가 발생할 수 있다. 또한 JVM이 설정한 모든 빈들이 적재될 수 있는 메모리를 확보해 놓아야 한다. 이를 위해 JVM Heap 메모리를 수정해 놓는 것도 좋은 방법이다. 지연 초기화 방법은 두 가지 방식을 보통 사용하는데, 하나는 자바 코드를 사용하는 방식이고 다른 하나는 환경 설정을 통한 방식이다.        

* 자바 코드: ```lazyInitialization``` 메서드 (```SpringApplicationBuilder```, ```setLazyInitialization```) 사용
* 환경 설정: ```spring.main.lazy-initialization=true```    

---
### **7.1.6.Application Availability**     
---
애플리케이션을 플랫폼에 배포할 때 인프라 플랫폼 정보를 제공 받을 수 있다. 예를 들어 ```kubernates Probe```와 같은 거라 볼 수 있다. 스프링 부트는 플랫폼 가용성 상태 관리를 위해 널리 사용하고 있는 ```liveness``` 와 ```readiness``` 를 지원하고 있다. 스프링 부트의 ```Actuator``` 를 사용하는 경우 상태 정보는 엔드 포인트 그룹으로 노출된다. 추가적으로 빈에 ```ApplicationAvailability``` 인터페이스 주입을 통해 상태 정보를 얻을 수 있다. 아래 내용들은 스프링 부트에서 상태를 어떻게 관리하고 있는지에 대해 설명하고 있다. 이 포스팅에서는 전체적인 설명 정도만 업급하였다.        

---
### **7.1.6.Application Events and Listeners**    
---
이 부분은 스프링 부트 애플리케이션의 시작 시점에서 어떠한 작업을 수행시키기 위한 내용으로 알려져 있다. 예를 들어 스프링 부트가 시작할 때 초기화가 필요한 경우라 생각하면 이해가 빠를 것이다. ```ContextRefreshEvent```와 같이 스프링 프레임워크에서 일반적으로 이벤트를 다루는 방법이 있다. ```SpringApplication``` 은 몇 가지 추가 이벤트를 전송한다.     


> **(Notes)**    
몇몇의 이벤트들은 ```ApplicationContext``` 가 생성되기 전에 발생한다. 그래서 해당 이벤트들은 ```@Bean``` 를 통해 리스너에 등록을 할 수 없다. 등록을 원한다면 ```SpringApplication.addListeners(..)``` 메소드 혹은  ```SpringApplicationBuilder.listeners(..)``` 를 통해 등록이 가능하다. 추가로 애플리케이션의 생성에 관계없이 이러한 리스너를 자동으로 등록하고 싶다면   ```META-INF/spring.factories``` 에 등록을 하면 된다.             
```org.springframework.context.ApplicationListener=com.example.project.MyListener```     

아래 부분 내용은 스프링 부트에서 제공하는 여러 이벤트를 사용할 수 있는 애플리케이션 이벤트들을 소개해 주고 있다. (자세하게 알고 싶은 분들은 참고해 봐도 좋을 거 같다.)    

---   
### **7.1.8.WebEnvironment**        
---    
스프링 애플리케이션은 ```ApplicationContext``` 를 통해 적절한 웹과 관련된 설정을 지원하고 있다. 이를 결정하는 데는 ```WebApplicationType``` 이 사용된다.   

* Spring MVC 는 ```AnnotationConfigServletWebServerApplicationContext``` 사용
* Spring WebFlux 는 ```AnnotationConfigReactiveWebServerApplicationContext``` 사용
* 그 이외의 경우에는 ```AnnotationConfigApplicationContext``` 사용

동일한 애플리케이션에서 ```Spring MVC``` 와 ```Spring WebFlux``` 가 존재하는 경우 기본적으로  ```Spring MVC``` 가 사용된다. 하지만 ```setWebApplicationType(WebApplicationType)``` 를 통해 재정의도 가능하다.    

(예시)
```java
SpringApplication springApplication = new SpringApplication();
springApplication.setWebApplicationType(WebApplicationType.NONE);
```     

---    
### **7.1.10.Using the ApplicationRunner or CommandLineRunner**
---

스프링 애플리케이션이 시작하기 전에 사용자가 원하는 코드를 넣고 싶다면, ```ApplicationRunner``` 혹은 ```CommandLineRunner``` 인터페이스를 구현하여 사용하면 된다. 이 2개의 인터페이스의 동작은 동일하다. ```run``` 이라는 메소드를 구현해 주기만 하면 된다. ```CommandLineRunner``` 의 Argument 는 String 배열 형태로 입력이 가능한 반면 ```ApplicationRunner``` 는 ```ApplicationArguments``` Argument로 입력할 수 있다.    

```java
@Component
public class MyCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        // Do something...
    }
}
```    

```java
@Component
public class MyCommandLineRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        // Do something...
    }
}
```

여러 개의 Runner를 사용하는 경우는 ```org.springframework.core.Ordered``` 인터페이스 혹은 ```org.springframework.core.annotation.Order``` 어노테이션을 통해 순서를 제어할 수 있다.     

---
### **7.2.Externalized Configuration**   
---
스프링 부트는 외부 설정을 지원함으로 동일한 애플리케이션 코드가 다른 환경에서 동작할 수 있게 해 준다. 사용자는 다양한 외부 설정 방법을 사용할 수 있다. (properties 파일, YAML 파일, 커맨드 라인 등)   
프로퍼티 값은  ```@Value``` 애노테이션을 통해 직접 코드에 주입된다. ```@Value``` 는 스프링에서 제공하는 ```Spring's Environment abstract``` 를 통해 설정된 환경에 접근이 가능하다. 또한 구조화된 객체를 바인딩하기 위해서는  ```@ConfigurationProperties``` 이라는 어노테이션도 제공해 주고 있다.     
    
스프링 부트는 특별한 ```PropertySource``` 호출 순서를 사용한다. ```PropertySource``` 는 값을 언제나 재 사용할 수 있도록 고안되었다. 아래 ```PropertySource``` 호출 순서를 살펴보자.    
    
1. 기본 프로퍼티 (```SpringApplication.setDefaultProperties```)
2. ```@Configuration``` 어노테이션과 함께 선언된 ```@PropertySource``` 어노테이션, 다만 ```logging.*```, ```spring.main.*``` 과 같은 몇몇의 프로퍼티들은 application context가 refresh 될 때까지 ```Environment``` 에 추가되지 않는다.
3. Config Data (예: ```application.properties``` 파일)  
4. ```RamdomValuePropertySource```   
5. OS 환경 설정
6. 자바 시스템 프로퍼티 (```System.getProperties()```) 
7. JNDI 속성 값 (```java:comp/env```)
8. ```ServletContext``` 초기 파라미터들
9. ```ServletConfig``` 초기 파라미터들
10. ```SPRING_APPLICATION_JSON``` 로 설정된 프로퍼티 (JSON 형태의 설정)    
```java -Dspring.application.json='{"key":"value"}' -jar myapp.jar```
11. 커맨드 라인 아규먼트 
12. 테스트에 적용된 프로퍼티 속성 (```@SpringBootTest```, test 어노테이션)  
13. 테스트에 적용된 ```@TestPropertySource``` 
14. devtools 설정 (```$HOME/.config/spring-boot```) 

      
3번에서 언급된 Config Data 설정을 조금 세분화 해 보면 다음과 같다. (많이 사용하는 설정) 
    
1. 패키지 내부에 애플리케이션 프로퍼티 (```application.properties``` 혹은 YAML)
2. 패키지 내부에 특별한 프로파일이 적용된 애플리케이션 프로퍼티 (```application-{profile}.properties``` 혹은 YAML)
3. 패키지 외부에 애플리케이션 프로퍼티 (```application.properties``` 혹은 YAML)
4. 패키지 외부에 특별한 프로파일이 적용된 애플리케이션 프로퍼티 (```application-{profile}.properties``` 혹은 YAML)    

     
예를 들어, ```@Component``` 어노테이션이 태깅되어 있는 클래스에 ```name``` 프로퍼티가 존재한다고 가정해 보자.      


```java
@Component
public class MyBean {
    @Value("${name}")
    private String name;
    // ...
}
```     

애플리케이션 클래스 패스 내에 존재하는 경우 ```application.propertis``` 에서 제공해 주는 ```name``` 속성을 가져올 수 있다. 물론 설정이 클래스 패스 내에 존재하지 않는 경우에도 가능하다. 추가적으로 커맨드 라인을 통해 프로퍼티를 제공해 줄 수 있는데, 다음과 같이 사용이 가능하다.     
     
```java -jar app.jar --name="Spring"```   

---