### **7.7.Developing Web Applications**     
---     
스프링 부트는 웹 애플리케이션을 개발하는 데 적합하다. 내장된 컨테이너로 HTTP 서버를 쉽게 만들 수 있다. 스프링 부트가 지원하는 내장 웹 컨테이너로는 Tomcat, Jetty, Netty, Undertow가 있다. 스프링 부트에서 웹 애플리케이션들을 개발하기 위해서는  ```spring-boot-starter-web``` 모듈을 사용한다. 추가로 리액티브 웹 애플리케이션도 지원하고 있는데, ```spring-boot-starter-webflux``` 모듈을 사용한다.      

---     
### **7.7.1.The "Spring Web MVC Framework"**    
---
Spring Web MVC Framework는 "model view controller" 웹 프레임워크이다. Spring MVC는 ```@Controller``` 혹은 ```@RestController``` 라는 특별한 빈을 통해 유입되는 HTTP 요청들을 처리하게 된다. 참고로 유입된 요청들은 컨트롤러 내부에 ```@RequestMapping``` 메소드가 유입된 HTTP 를 맵핑 시켜주고 처리되게 된다.        

```java
@RestController
@RequestMapping("/users")
public class MyRestController {

    private final UserRepository userRepository;

    private final CustomerRepository customerRepository;

    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{user}")
    public User getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId).get();
    }

    @GetMapping("/{user}/customers")
    public List<Customer> getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();
    }

    @DeleteMapping("/{user}")
    public void deleteUser(@PathVariable Long userId) {
        this.userRepository.deleteById(userId);
    }

}
```    
Spring MVC는 스프링 프레임워크의 핵심적인 내용이다. 조금 더 상세한 정보는 아래 링크를 통해 확인하면 된다.      
(https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/web.html#mvc)      

---
**Spring MVC Auto-configuration**     

---    
스프링 부트에서 Spring MVC를 잘 동작하게 하기 위해 auto-configuration 을 제공한다. auto-configuration은 스프링 부트에 아래와 같은 기능을 추가해 준다.    

* ```ContentNegotiatingViewResolver``` 과 ```BeanNameViewResolver``` Beans      
* WebJars에 포함된 정적 리소스 자원들 지원    
* ```Converter```, ```GenericConverter```, ```Formatter``` Beans 자동등록      
* ```MessageCodesResolver``` 자동 등록     
* 정적 ```index.html``` 파일 지원      
* ```ConfigurableWebBindingInitializer``` 자동 등록     

만약 사용자가 커스터마이즈(interceptor, formatters, view, controller 등)를 원한다면, ```@EnableWebMvc``` 필요없이, ```WebMvcConfigurer``` 타입 클래스가 포함된 클래스에 ```@Configuration``` 를 추가해 주면 된다.         


만약 사용자가 ```RequestMappingHandlerMapping```, ```RequestMappingHandlerAdapter```, ```RequestMappingHandlerAdapter``` 을 커스터마이즈하기 원한다면, 해당 컴포넡트들의 커스터마이즈를 제공해 주는 ```WebMvcRegistrations``` Bean을 등록해야 한다.        

만약 사용자가 Spring MVC 기능을 제어하길 원한다면, ```@EnableWebMvc``` 애노테이션을 가지고 있는 ```@Configuration``` 를 추가하거나 javadoc 에 명시된 내용처럼 ```@EnableWebMvc``` 을 선언하면 된다.        

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}
```     
---

**HttpMessageConverters**     

---

Spring MVC 는 ```HttpMessageConverter UTF-8``` 를 사용한다.     
만약 사용자가 컨버터를 커스터마이즈 하길 원한다면, 스프링 부트에서 제공하는 ```HttpMessageConverters```  클래스를 사용하면 된다.       

```java
@Configuration(proxyBeanMethods = false)
public class MyHttpMessageConvertersConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter<?> additional = new AdditionalHttpMessageConverter();
        HttpMessageConverter<?> another = new AnotherHttpMessageConverter();
        return new HttpMessageConverters(additional, another);
    }

}
```        
---
**Custom JSON Serializers and Deserializers**

---       

Jackson을 사용하게 되면 JSON 데이터를 Serialize 또는 Deserialize 할 수 있다. 사용자는 ```JsonSerializer``` 혹은 ```JsonDeserializer``` 클래스를 사용하여 작성이 가능하다. 커스텀된 serializers는 보통 ```@JsonComponent``` 를 사용한다.     

```java
@JsonComponent
public class MyJsonComponent {

    public static class Serializer extends JsonSerializer<MyObject> {

        @Override
        public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException {
            jgen.writeStringField("name", value.getName());
            jgen.writeNumberField("age", value.getAge());
        }

    }

    public static class Deserializer extends JsonDeserializer<MyObject> {

        @Override
        public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt)
                throws IOException, JsonProcessingException {
            ObjectCodec codec = jsonParser.getCodec();
            JsonNode tree = codec.readTree(jsonParser);
            String name = tree.get("name").textValue();
            int age = tree.get("age").intValue();
            return new MyObject(name, age);
        }

    }

}
```

```@JsonComponent``` 빈은 자동적으로 ```ApplicationContext``` 에 등록된다. 왜냐하면 ```@JsonComponent``` 는 메타 애노테이션으(```@Component```)로 컴포넌트 스캔 시 적용된다.      

스프링 부트는 ```JsonObjectSerializer```, ```JsonObjectDeserializer``` 제공하는 데 이것은 Jackson serializer obejct 기능의 대체안으로 사용가능하다.     

```java
@JsonComponent
public class MyJsonComponent {

    public static class Serializer extends JsonObjectSerializer<MyObject> {

        @Override
        protected void serializeObject(MyObject value, JsonGenerator jgen, SerializerProvider provider)
                throws IOException {
            jgen.writeStringField("name", value.getName());
            jgen.writeNumberField("age", value.getAge());
        }

    }

    public static class Deserializer extends JsonObjectDeserializer<MyObject> {

        @Override
        protected MyObject deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,
                JsonNode tree) throws IOException {
            String name = nullSafeValue(tree.get("name"), String.class);
            int age = nullSafeValue(tree.get("age"), Integer.class);
            return new MyObject(name, age);
        }

    }

}
```    

---

**Static Content**   

---
기본적으로 스프링 부트에서 정적 컨텐츠는 ```/static``` (or ```/public```, ```/resource``` or ```/META-INF/resource```) 경로에 존재한다. 해당 경로는 클래스 패스 내에 존재하거나 ```ServletContext``` 의 루트 경로에 존재하는 경로이다. Spring MVC의 ```ResourceHttpRequestHandler``` 를 사용한다. 이 때 스프링 MVC의 ```WebMvcConfigurer```를 추가하여 ```addResourceHandlers``` 메소드를 재정의하면 이 동작을 수정할 수 있다.    
 
웹 애플리케이션 컨테이너의 디폴트 서블릿도 활성화된다. 디폴트 서블릿은 스프링이 요청을 처리하지 않는 경우 ```ServletContext``` 루트 경로의 정적 컨텐츠를 제공한다. 하지만 스프링 MVC Configuration을 수정하지 않는다면 이런 일은 거의 발생하지 않는다. 스프링은 ```DispatcherServlet``` 을 통해 모든 요청을 처리할 수 있기 때문에 크게 신경 쓰지 않아도 된다. 기본적으로 정적 리소스는 ```"/**"``` 맵핑되지만 ```spring.mvc.static-path-pattern``` 프로퍼티를 통해 변경 가능하다. 예를 들어 아래 예제는 ```"resources/**"``` 경로로 리소스를 맵핑한 경우이다.     

```proerties
spring.mvc.static-path-pattern=/resources/**
```     

또한 ```spring.web.resources.static-locations``` 프로퍼티를 통해 정적 컨텐츠 경로를 수정해도 된다. (여기 정의한 값으로 기본 경로가 대체됨)


앞에서 업근한 표준 정적 컨텐츠 경로 이외에도 "Webjars"를 위한 특별한 경로가 존재한다. ```"/webjars/**"``` 경로를 사용하는 모든 리소느는 Webjars 형식으로 패키징되어 있다면 jar 파일에서 서빙이 가능하다.     

>**(Tips)**    
애플리케이션을 jar로 패키징한다면 ```"src/main/webapp"``` 경로는 사용하지 않는 게 좋다. 이 경로는 공통 표준 경로지만, war 패키지에서만 동작하며 jar로 생성된 빌드 툴들은 대부분 무시하고 넘어간다.         

스프링 부트는 스프링 MVC에서 제공하는 고급 리소스 핸들링 기능도 지원해서 정적 리소스에 캐시 버스팅(cache-bursting) 기능도 사용 가능하고 webjars 버전을 명시하지 않고도 URL을 지정할 수 있다.       

URL을 Webjars 버전 없이 사용하고 싶다면 ```webjars-locator-core``` 의존성을 추가해 줘야 한다. 그런 다음에 원하는 Webjars를 선택하면 된다. JQuery를 예로 들면, ```“/webjars/jquery/jquery.min.js”``` 을 추가하면 ```“/webjars/jquery/x.y.z/jquery.min.js”``` 까지 추가된다. 여기서 ```x, y, x``` 는 Webjars의 버전이다.      

캐시 버스팅을 사용하기 위해서는 아래 설정을 통해 구성이 가능하다. URL에 ```"<link href=”/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css”/>"``` 와 같이 컨텐츠 해시값을 추가해 준다.     


```properties
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
```     

>**(Note)**     
리소스 경로를 가르키고 있는 링크는 Thymeleaf와 FreeMarker에서 자동설정되는 ```ResourceUrlEncodingFilter``` 에 의해 런타임에 재 작성된다. 다만 JSP를 사용할 때는 수동으로 선언해야 한다. 다른 템플릿 엔진들은 현재 자동설정을 지원하지 않지만 커스텀 템플릿 매크로/헬퍼와 ```RsourceUrlEncodingFilter``` 를 사용할 수 있다. 

---

**Error Handling**     

---
기본적으로 스프링 부트는 모든 에러에 대해 ```/error``` 맵핑을 제공해 주고 있고 모든 요청 에러에 대해서 "global" 에러 페이지도 제공해 줄 수 있다. 클라이언트를 위해 JSON 응답에 에러에 대한 상태코드와 에러 메시지도 함께 제공된다. 별도의 세팅을 하지 않은 경우 에러 발생 시, 브라우저에서는 "whitelabel" 이라는 view 를 만나게 된다. 만약 사용자가 커스텀 에러를 사용하고 싶다면 ```server.error``` 의 다양한 프로퍼리를 사용하여 커스텀이 가능하다. 나만의 에러 환경을 만들고 싶다면 ```ErrorController``` 를 구현하여 빈으로 등록하고 기존 매커니즘을 사용하되 내용 변경을 원한다면 ```ErrorAttributes``` 타입 빈을 추가하면 된다.      

>**(Note)**     
```ErrorController``` 를 커스텀할 때는 기본 클래스로 ```BaseErrorController``` 를 활용할 수 있다. 특히 새로운 컨텐츠 타입을 추가하는 경우에는 유용하다. 예를 들어 기본 ```ErrorController``` 는 ```text/html``` 처리를 위한 메서드를 별도로 지정하고 그외 다른 컨텐츠 타입들은 다른 fallback을 지정하는 경우이다. ```BasicErrorController```  를 상속하여 public 메서드를 추가하고 ```@RequestMapping``` 에 produces 속성을 지정해 주면 된다.       

아례 예제처럼 특정 컨트롤러나 예외 타입에서 반환할 JSON 문서를 커스텀 할 수 있다.    

```java
@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {

    @ResponseBody
    @ExceptionHandler(MyException.class)
    public ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity<>(new MyErrorBody(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        HttpStatus status = HttpStatus.resolve(code);
        return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
    }

}
```   

위 예제에서는 ```SomeController``` 와 같은 패키지에서 정의한 컨트롤러에서 ```YourException``` 이 발생하면 에러를 ```ErrorAttributes``` 로 표현하지 않고 ```CustomErrorType``` POJO 객체를 JSON 문서로 표현한다.    

```java
@Controller
public class MyController {

    @ExceptionHandler(CustomException.class)
    String handleCustomException(HttpServletRequest request, CustomException ex) {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex);
        return "errorView";
    }

}
```    
---